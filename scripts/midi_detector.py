"""
MIDI Detector - Detect and manage USB MIDI devices via amidiminder
Handles persistent MIDI routing to /etc/amidiminder.rules
"""
import subprocess
import re
import os

# System devices to ignore
IGNORE_DEVICES = [
    'Midi Through',
    'APC Key 25 mk2',
    'RtMidiIn Client',
    'RtMidiOut Client',
    'Pure Data',
    'Client-',  # Generic client names like "Client-133"
]

def get_available_midi_devices():
    """
    Run amidiminder and parse output to find user MIDI devices
    
    Returns:
        list: List of tuples (device_name, port_name, full_identifier)
              e.g., [('CRAVE', 'CRAVE MIDI 1', 'CRAVE:CRAVE MIDI 1')]
    """
    try:
        # Run amidiminder briefly to detect ports
        # Use timeout to kill it after 1 second (it runs continuously)
        result = subprocess.run(
            ['amidiminder'],
            capture_output=True,
            text=True,
            timeout=1
        )
    except subprocess.TimeoutExpired as e:
        # Expected - amidiminder runs continuously, we just want initial output
        result = e
    
    if not hasattr(result, 'stdout') or not result.stdout:
        return []
    
    devices = []
    seen = set()  # Avoid duplicates
    
    for line in result.stdout.split('\n'):
        if 'port added' in line:
            # Parse: port added CRAVE:CRAVE MIDI 1 [32:0]
            match = re.search(r'port added (.+?):(.+?) \[', line)
            if match:
                device_name = match.group(1).strip()
                port_name = match.group(2).strip()
                full_id = f"{device_name}:{port_name}"
                
                # Filter out system devices
                if not should_ignore_device(device_name) and full_id not in seen:
                    devices.append((device_name, port_name, full_id))
                    seen.add(full_id)
    
    return devices


def should_ignore_device(device_name):
    """
    Check if device should be ignored (system device)
    
    Args:
        device_name: Device name from amidiminder (e.g., "CRAVE")
    
    Returns:
        bool: True if should be ignored
    """
    for ignore_prefix in IGNORE_DEVICES:
        if device_name.startswith(ignore_prefix):
            return True
    return False


def get_current_midi_device():
    """
    Read current MIDI device from /etc/amidiminder.rules
    
    Returns:
        str or None: Current device identifier (e.g., "CRAVE:CRAVE MIDI 1")
                     or None if not configured
    """
    try:
        with open('/etc/amidiminder.rules', 'r') as f:
            for line in f:
                # Look for: Pure Data:Pure Data Midi-Out 2 --> DEVICE:PORT
                if 'Pure Data:Pure Data Midi-Out 2' in line and '-->' in line:
                    match = re.search(r'--> (.+)', line)
                    if match:
                        return match.group(1).strip()
    except Exception as e:
        print(f"Error reading amidiminder.rules: {e}")
    
    return None


def set_midi_device(device_full_id):
    """
    Write MIDI device rule to /etc/amidiminder.rules
    Creates connection: Pure Data Midi-Out 2 --> Selected Device
    
    Args:
        device_full_id: Full device identifier (e.g., "CRAVE:CRAVE MIDI 1")
    
    Returns:
        tuple: (success: bool, message: str)
    """
    try:
        # Read existing rules file
        rules_path = '/etc/amidiminder.rules'
        
        # Check if file exists
        if os.path.exists(rules_path):
            with open(rules_path, 'r') as f:
                lines = f.readlines()
        else:
            # Create minimal template
            lines = [
                "### amidiminder Rules file\n",
                "\n",
                "# Auto-generated by Molipe\n",
                "\n",
            ]
        
        # Remove any existing Pure Data Midi-Out 2 rules
        new_lines = []
        for line in lines:
            if 'Pure Data:Pure Data Midi-Out 2' not in line:
                new_lines.append(line)
        
        # Add new rule at the end
        if not new_lines[-1].endswith('\n'):
            new_lines.append('\n')
        
        new_rule = f"Pure Data:Pure Data Midi-Out 2 --> {device_full_id}\n"
        new_lines.append(new_rule)
        
        # Write back using sudo
        content = ''.join(new_lines)
        
        # Write with sudo tee (reliable way to write as root)
        write_result = subprocess.run(
            ['sudo', 'tee', rules_path],
            input=content,
            text=True,
            capture_output=True,
            timeout=5
        )
        
        if write_result.returncode != 0:
            return False, f"Failed to write rules file: {write_result.stderr}"
        
        # Restart amidiminder service to apply changes
        restart_result = subprocess.run(
            ['sudo', 'systemctl', 'restart', 'amidiminder'],
            capture_output=True,
            timeout=5
        )
        
        if restart_result.returncode != 0:
            return False, f"Failed to restart amidiminder: {restart_result.stderr}"
        
        print(f"âœ" MIDI device set: {device_full_id}")
        return True, device_full_id
    
    except subprocess.TimeoutExpired:
        return False, "Timeout while configuring MIDI"
    except Exception as e:
        return False, f"Error: {str(e)}"


def clear_midi_device():
    """
    Remove MIDI device rule from /etc/amidiminder.rules
    
    Returns:
        tuple: (success: bool, message: str)
    """
    try:
        rules_path = '/etc/amidiminder.rules'
        
        if not os.path.exists(rules_path):
            return True, "No rules file exists"
        
        # Read existing rules
        with open(rules_path, 'r') as f:
            lines = f.readlines()
        
        # Remove Pure Data Midi-Out 2 rules
        new_lines = []
        for line in lines:
            if 'Pure Data:Pure Data Midi-Out 2' not in line:
                new_lines.append(line)
        
        # Write back
        content = ''.join(new_lines)
        
        write_result = subprocess.run(
            ['sudo', 'tee', rules_path],
            input=content,
            text=True,
            capture_output=True,
            timeout=5
        )
        
        if write_result.returncode != 0:
            return False, "Failed to write rules file"
        
        # Restart amidiminder
        subprocess.run(
            ['sudo', 'systemctl', 'restart', 'amidiminder'],
            capture_output=True,
            timeout=5
        )
        
        return True, "MIDI device cleared"
    
    except Exception as e:
        return False, f"Error: {str(e)}"


# Test function
if __name__ == "__main__":
    print("=== MIDI Device Detector ===\n")
    
    print("Detecting MIDI devices...")
    devices = get_available_midi_devices()
    
    if devices:
        print(f"\nFound {len(devices)} user MIDI device(s):")
        for device_name, port_name, full_id in devices:
            print(f"  - {device_name}: {port_name}")
            print(f"    Full ID: {full_id}")
    else:
        print("\nNo user MIDI devices found")
    
    print("\nCurrent MIDI device:")
    current = get_current_midi_device()
    if current:
        print(f"  {current}")
    else:
        print("  (none configured)")
